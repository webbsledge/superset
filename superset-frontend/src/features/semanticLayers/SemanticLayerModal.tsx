/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
import { useState, useEffect, useCallback, useRef } from 'react';
import { t } from '@apache-superset/core';
import { styled } from '@apache-superset/core/ui';
import { SupersetClient } from '@superset-ui/core';
import { Input, Spin } from 'antd';
import { Select } from '@superset-ui/core/components';
import { Icons } from '@superset-ui/core/components/Icons';
import { JsonForms, withJsonFormsControlProps } from '@jsonforms/react';
import type {
  JsonSchema,
  UISchemaElement,
  ControlProps,
} from '@jsonforms/core';
import {
  rankWith,
  and,
  isStringControl,
  formatIs,
  schemaMatches,
} from '@jsonforms/core';
import {
  rendererRegistryEntries,
  cellRegistryEntries,
  TextControl,
} from '@great-expectations/jsonforms-antd-renderers';
import type { ErrorObject } from 'ajv';
import {
  StandardModal,
  ModalFormField,
  MODAL_STANDARD_WIDTH,
  MODAL_MEDIUM_WIDTH,
} from 'src/components/Modal';

/**
 * Custom renderer that renders `Input.Password` for fields with
 * `format: "password"` in the JSON Schema (e.g. Pydantic `SecretStr`).
 */
function PasswordControl(props: ControlProps) {
  const uischema = {
    ...props.uischema,
    options: { ...props.uischema.options, type: 'password' },
  };
  return TextControl({ ...props, uischema });
}
const PasswordRenderer = withJsonFormsControlProps(PasswordControl);
const passwordEntry = {
  tester: rankWith(3, and(isStringControl, formatIs('password'))),
  renderer: PasswordRenderer,
};

/**
 * Renderer for `const` properties (e.g. Pydantic discriminator fields).
 * Renders nothing visually but ensures the const value is set in form data,
 * so discriminated unions resolve correctly on the backend.
 */
function ConstControl({ data, handleChange, path, schema }: ControlProps) {
  const constValue = (schema as Record<string, unknown>).const;
  useEffect(() => {
    if (constValue !== undefined && data !== constValue) {
      handleChange(path, constValue);
    }
  }, [constValue, data, handleChange, path]);
  return null;
}
const ConstRenderer = withJsonFormsControlProps(ConstControl);
const constEntry = {
  tester: rankWith(10, schemaMatches(s => s !== undefined && 'const' in s)),
  renderer: ConstRenderer,
};

/**
 * Renderer for fields marked `x-dynamic` in the JSON Schema.
 * Shows a loading spinner inside the input while the schema is being
 * refreshed with dynamic values from the backend.
 */
function DynamicFieldControl(props: ControlProps) {
  const { refreshingSchema, formData: cfgData } = props.config ?? {};
  const deps = (props.schema as Record<string, unknown>)?.['x-dependsOn'];
  const refreshing =
    refreshingSchema &&
    Array.isArray(deps) &&
    areDependenciesSatisfied(deps as string[], (cfgData as Record<string, unknown>) ?? {});

  if (!refreshing) {
    return TextControl(props);
  }

  const uischema = {
    ...props.uischema,
    options: {
      ...props.uischema.options,
      placeholderText: t('Loading...'),
      inputProps: { suffix: <Spin size="small" /> },
    },
  };
  return TextControl({ ...props, uischema, enabled: false });
}
const DynamicFieldRenderer = withJsonFormsControlProps(DynamicFieldControl);
const dynamicFieldEntry = {
  tester: rankWith(
    3,
    and(
      isStringControl,
      schemaMatches(
        s => (s as Record<string, unknown>)?.['x-dynamic'] === true,
      ),
    ),
  ),
  renderer: DynamicFieldRenderer,
};

const renderers = [
  ...rendererRegistryEntries,
  passwordEntry,
  constEntry,
  dynamicFieldEntry,
];

type Step = 'type' | 'config';
type ValidationMode = 'ValidateAndHide' | 'ValidateAndShow';

const SCHEMA_REFRESH_DEBOUNCE_MS = 500;

/**
 * Removes empty `enum` arrays from schema properties. The JSON Schema spec
 * requires `enum` to have at least one item, and AJV rejects empty arrays.
 * Fields with empty enums are rendered as plain text inputs instead.
 */
function sanitizeSchema(schema: JsonSchema): JsonSchema {
  if (!schema.properties) return schema;
  const properties: Record<string, JsonSchema> = {};
  for (const [key, prop] of Object.entries(schema.properties)) {
    if (
      typeof prop === 'object' &&
      prop !== null &&
      'enum' in prop &&
      Array.isArray(prop.enum) &&
      prop.enum.length === 0
    ) {
      const { enum: _empty, ...rest } = prop;
      properties[key] = rest;
    } else {
      properties[key] = prop as JsonSchema;
    }
  }
  return { ...schema, properties };
}

/**
 * Builds a JSON Forms UI schema from a JSON Schema, using the first
 * `examples` entry as placeholder text for each string property.
 */
function buildUiSchema(
  schema: JsonSchema,
): UISchemaElement | undefined {
  if (!schema.properties) return undefined;

  // Use explicit property order from backend if available,
  // otherwise fall back to the JSON object key order
  const propertyOrder: string[] =
    (schema as Record<string, unknown>)['x-propertyOrder'] as string[] ??
    Object.keys(schema.properties);

  const elements = propertyOrder
    .filter(key => key in (schema.properties ?? {}))
    .map(key => {
      const prop = schema.properties![key];
      const control: Record<string, unknown> = {
        type: 'Control',
        scope: `#/properties/${key}`,
      };
      if (typeof prop === 'object' && prop !== null) {
        const options: Record<string, unknown> = {};
        if (
          'examples' in prop &&
          Array.isArray(prop.examples) &&
          prop.examples.length > 0
        ) {
          options.placeholderText = String(prop.examples[0]);
        }
        if ('description' in prop && typeof prop.description === 'string') {
          options.tooltip = prop.description;
        }
        if (Object.keys(options).length > 0) {
          control.options = options;
        }
      }
      return control;
    });
  return { type: 'VerticalLayout', elements } as UISchemaElement;
}

/**
 * Extracts dynamic field dependency mappings from the schema.
 * Returns a map of field name â†’ list of dependency field names.
 */
function getDynamicDependencies(
  schema: JsonSchema,
): Record<string, string[]> {
  const deps: Record<string, string[]> = {};
  if (!schema.properties) return deps;
  for (const [key, prop] of Object.entries(schema.properties)) {
    if (
      typeof prop === 'object' &&
      prop !== null &&
      'x-dynamic' in prop &&
      'x-dependsOn' in prop &&
      Array.isArray((prop as Record<string, unknown>)['x-dependsOn'])
    ) {
      deps[key] = (prop as Record<string, unknown>)[
        'x-dependsOn'
      ] as string[];
    }
  }
  return deps;
}

/**
 * Checks whether all dependency values are filled (non-empty).
 * Handles nested objects (like auth) by checking they have at least one key.
 */
function areDependenciesSatisfied(
  dependencies: string[],
  data: Record<string, unknown>,
): boolean {
  return dependencies.every(dep => {
    const value = data[dep];
    if (value === null || value === undefined || value === '') return false;
    if (typeof value === 'object' && Object.keys(value).length === 0)
      return false;
    return true;
  });
}

/**
 * Serializes the dependency values for a set of fields into a stable string
 * for comparison, so we only re-fetch when dependency values actually change.
 */
function serializeDependencyValues(
  dynamicDeps: Record<string, string[]>,
  data: Record<string, unknown>,
): string {
  const allDepKeys = new Set<string>();
  for (const deps of Object.values(dynamicDeps)) {
    for (const dep of deps) {
      allDepKeys.add(dep);
    }
  }
  const snapshot: Record<string, unknown> = {};
  for (const key of [...allDepKeys].sort()) {
    snapshot[key] = data[key];
  }
  return JSON.stringify(snapshot);
}

const ModalContent = styled.div`
  padding: ${({ theme }) => theme.sizeUnit * 4}px;
`;

const BackLink = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colorPrimary};
  cursor: pointer;
  padding: 0;
  font-size: ${({ theme }) => theme.fontSize[1]}px;
  margin-bottom: ${({ theme }) => theme.sizeUnit * 2}px;
  display: inline-flex;
  align-items: center;
  gap: ${({ theme }) => theme.sizeUnit}px;

  &:hover {
    text-decoration: underline;
  }
`;

interface SemanticLayerType {
  id: string;
  name: string;
  description: string;
}

interface SemanticLayerModalProps {
  show: boolean;
  onHide: () => void;
  addDangerToast: (msg: string) => void;
  addSuccessToast: (msg: string) => void;
}

export default function SemanticLayerModal({
  show,
  onHide,
  addDangerToast,
  addSuccessToast,
}: SemanticLayerModalProps) {
  const [step, setStep] = useState<Step>('type');
  const [name, setName] = useState('');
  const [selectedType, setSelectedType] = useState<string | null>(null);
  const [types, setTypes] = useState<SemanticLayerType[]>([]);
  const [loading, setLoading] = useState(false);
  const [configSchema, setConfigSchema] = useState<JsonSchema | null>(null);
  const [uiSchema, setUiSchema] = useState<UISchemaElement | undefined>(
    undefined,
  );
  const [formData, setFormData] = useState<Record<string, unknown>>({});
  const [saving, setSaving] = useState(false);
  const [hasErrors, setHasErrors] = useState(true);
  const [refreshingSchema, setRefreshingSchema] = useState(false);
  const [validationMode, setValidationMode] =
    useState<ValidationMode>('ValidateAndHide');
  const errorsRef = useRef<ErrorObject[]>([]);
  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const lastDepSnapshotRef = useRef<string>('');
  const dynamicDepsRef = useRef<Record<string, string[]>>({});

  const fetchTypes = useCallback(async () => {
    setLoading(true);
    try {
      const { json } = await SupersetClient.get({
        endpoint: '/api/v1/semantic_layer/types',
      });
      setTypes(json.result ?? []);
    } catch {
      addDangerToast(
        t('An error occurred while fetching semantic layer types'),
      );
    } finally {
      setLoading(false);
    }
  }, [addDangerToast]);

  const applySchema = useCallback((rawSchema: JsonSchema) => {
    const schema = sanitizeSchema(rawSchema);
    setConfigSchema(schema);
    setUiSchema(buildUiSchema(schema));
    dynamicDepsRef.current = getDynamicDependencies(rawSchema);
  }, []);

  const fetchConfigSchema = useCallback(
    async (type: string, configuration?: Record<string, unknown>) => {
      const isInitialFetch = !configuration;
      if (isInitialFetch) setLoading(true);
      else setRefreshingSchema(true);
      try {
        const { json } = await SupersetClient.post({
          endpoint: '/api/v1/semantic_layer/schema/configuration',
          jsonPayload: { type, configuration },
        });
        applySchema(json.result);
        if (isInitialFetch) setStep('config');
      } catch {
        if (isInitialFetch) {
          addDangerToast(
            t('An error occurred while fetching the configuration schema'),
          );
        }
      } finally {
        if (isInitialFetch) setLoading(false);
        else setRefreshingSchema(false);
      }
    },
    [addDangerToast, applySchema],
  );

  useEffect(() => {
    if (show) {
      fetchTypes();
    } else {
      setStep('type');
      setName('');
      setSelectedType(null);
      setTypes([]);
      setConfigSchema(null);
      setUiSchema(undefined);
      setFormData({});
      setHasErrors(true);
      setRefreshingSchema(false);
      setValidationMode('ValidateAndHide');
      errorsRef.current = [];
      lastDepSnapshotRef.current = '';
      dynamicDepsRef.current = {};
      if (debounceTimerRef.current) clearTimeout(debounceTimerRef.current);
    }
  }, [show, fetchTypes]);

  const handleStepAdvance = () => {
    if (selectedType) {
      fetchConfigSchema(selectedType);
    }
  };

  const handleBack = () => {
    setStep('type');
    setConfigSchema(null);
    setUiSchema(undefined);
    setFormData({});
    setValidationMode('ValidateAndHide');
    errorsRef.current = [];
    lastDepSnapshotRef.current = '';
    dynamicDepsRef.current = {};
    if (debounceTimerRef.current) clearTimeout(debounceTimerRef.current);
  };

  const handleCreate = async () => {
    setSaving(true);
    try {
      await SupersetClient.post({
        endpoint: '/api/v1/semantic_layer/',
        jsonPayload: { name, type: selectedType, configuration: formData },
      });
      addSuccessToast(t('Semantic layer created'));
      onHide();
    } catch {
      addDangerToast(t('An error occurred while creating the semantic layer'));
    } finally {
      setSaving(false);
    }
  };

  const handleSave = () => {
    if (step === 'type') {
      handleStepAdvance();
    } else {
      setValidationMode('ValidateAndShow');
      if (errorsRef.current.length === 0) {
        handleCreate();
      }
    }
  };

  const maybeRefreshSchema = useCallback(
    (data: Record<string, unknown>) => {
      if (!selectedType) return;

      const dynamicDeps = dynamicDepsRef.current;
      if (Object.keys(dynamicDeps).length === 0) return;

      // Check if any dynamic field has all dependencies satisfied
      const hasSatisfiedDeps = Object.values(dynamicDeps).some(deps =>
        areDependenciesSatisfied(deps, data),
      );
      if (!hasSatisfiedDeps) return;

      // Only re-fetch if dependency values actually changed
      const snapshot = serializeDependencyValues(dynamicDeps, data);
      if (snapshot === lastDepSnapshotRef.current) return;
      lastDepSnapshotRef.current = snapshot;

      if (debounceTimerRef.current) clearTimeout(debounceTimerRef.current);
      debounceTimerRef.current = setTimeout(() => {
        fetchConfigSchema(selectedType, data);
      }, SCHEMA_REFRESH_DEBOUNCE_MS);
    },
    [selectedType, fetchConfigSchema],
  );

  const handleFormChange = useCallback(
    ({ data, errors }: { data: Record<string, unknown>; errors?: ErrorObject[] }) => {
      setFormData(data);
      errorsRef.current = errors ?? [];
      setHasErrors(errorsRef.current.length > 0);
      if (
        validationMode === 'ValidateAndShow' &&
        errorsRef.current.length === 0
      ) {
        handleCreate();
      }
      maybeRefreshSchema(data);
    },
    [validationMode, handleCreate, maybeRefreshSchema],
  );

  const selectedTypeName =
    types.find(type => type.id === selectedType)?.name ?? '';

  const title =
    step === 'type'
      ? t('New Semantic Layer')
      : t('Configure %s', selectedTypeName);

  return (
    <StandardModal
      show={show}
      onHide={onHide}
      onSave={handleSave}
      title={title}
      icon={<Icons.PlusOutlined />}
      width={step === 'type' ? MODAL_STANDARD_WIDTH : MODAL_MEDIUM_WIDTH}
      saveDisabled={
        step === 'type' ? !selectedType : saving || !name.trim() || hasErrors
      }
      saveText={step === 'type' ? undefined : t('Create')}
      saveLoading={saving}
      contentLoading={loading}
    >
      {step === 'type' ? (
        <ModalContent>
          <ModalFormField label={t('Type')}>
            <Select
              ariaLabel={t('Semantic layer type')}
              placeholder={t('Select a semantic layer type')}
              value={selectedType}
              onChange={value => setSelectedType(value as string)}
              options={types.map(type => ({
                value: type.id,
                label: type.name,
              }))}
              getPopupContainer={() => document.body}
              dropdownAlign={{
                points: ['tl', 'bl'],
                offset: [0, 4],
                overflow: { adjustX: 0, adjustY: 1 },
              }}
            />
          </ModalFormField>
        </ModalContent>
      ) : (
        <ModalContent>
          <BackLink type="button" onClick={handleBack}>
            <Icons.CaretLeftOutlined iconSize="s" />
            {t('Back')}
          </BackLink>
          <ModalFormField label={t('Name')} required>
            <Input
              value={name}
              onChange={e => setName(e.target.value)}
              placeholder={t('Name of the semantic layer')}
            />
          </ModalFormField>
          {configSchema && (
            <JsonForms
              schema={configSchema}
              uischema={uiSchema}
              data={formData}
              renderers={renderers}
              cells={cellRegistryEntries}
              config={{ refreshingSchema, formData }}
              validationMode={validationMode}
              onChange={handleFormChange}
            />
          )}
        </ModalContent>
      )}
    </StandardModal>
  );
}
